---
title: "SimBio: a flexible and extensible Python package for systems modelling"
bibliography: bibliography.bib
format:
  html:
    number-sections: true
    anchor-sections: true
  pdf:
    documentclass: scrartcl
    papersize: a4
    geometry:
        - margin=20mm
    pdf-engine: tectonic
    number-sections: true
    colorlinks: true
---

# Introduction

Chemical Reaction Networks (CRN)
are the basis of many models used across the biological sciences and epidemiology.
They consist of a set of species and reactions that mediate conversions between them.
Several modalities exist to simulate these systems:
deterministic Ordinary Differential Equations (ODE) to model a macroscopic behavior,
Stochastic Differential Equations (SDE) to model microscopic fluctuations,
and jump processes (Gillespie-like simulations) to take into account the discreteness of the populations.
Instead of writing the equations directly for each of these formulations
which is error-prone and hard to reuse,
these models can be written in a higher level description
which can be compiled for these different types of simulations.

Several tools already exist to define and simulate these systems.
In particular,
BioSimulators.org [@shaikhBioSimulatorsCentralRegistry2022],
a registry of simulation tools,
list at least 15 Python softwares.
Some of them are:

1. COPASI [@hoopsCOPASICOmplexPAthway2006],
a stand-alone software
which provides a Graphical User Interface (GUI) to define and simulate models.
2. Tellurium [@choiTelluriumExtensiblePythonbased2018],
which defines itself as a Python-based modeling environment
and uses a C++ library called libRoadRunner [@welshLibRoadRunnerHighPerformance2023] to simulate them.
3. PySB [@lopezProgrammingBiologicalModels2013],
a Python library
that created a DSL using standard Python to define models
which are then compiled to ODE using a Perl library called BioNetGen [@harrisBioNetGenAdvancesRulebased2016].

A limitation of these tools is their extensibility from Python,
as they are or use wrapped libraries in other languages.
As such, they allow to "control" the model definition and simulation in a Python script,
but we cannot leverage other packages from the huge Python community
to change the way the simulation is carried out.
In some sense, we could say that
they facilitate not having to export the simulation result to a CSV file
and then loading it in Python to continue the analysis.

Another weak point is related to the way the models are written.
While most tools support standards such as the System Biology Markup Language (SBML) [@huckaSBMLL3V2],
no one is expected to write an SBML file directly.
Tellurium uses a Domain Specific Language (DSL) called Antimony [@smithAntimonyModularModel2009],
which can be translated to SBML.
A DSL permits to reuse of the code *as is* in different programming environments,
but will not be recognized in Integrated Development Enviromnents (IDE)
and, then, cannot provide the development experience we have come to expect:
syntax highlighting, code completion, refactoring, static analysis, among others.
This has been recognized by the community,
and an extension for Visual Studio Code has been created as part of a master thesis [@vscode-antimony].
But maintaining it into the future could be burdensome for the smaller systems biology community.

To address these two issues,
we developed SimBio,
a Python package to define and simulate reaction networks.
From the end-user point of view,
it is focused on providing an ergonomic experience
by integrating well with IDEs and static analysis tools
through the use of standard modern Python syntax.
From the power-user point of view,
it can be extended from Python,
since its coded in pure Python.
Finally,
from the developer/maintainer point of view,
it has a modular architecture with a clear separation of concerns,
making it easier to maintain or to contribute new code.

the models can be easily introspected,
and simulation extended from Python.
Clean API to create tools (graphs, tables, etc)

# Results

Modular code architecture enhances reusability, extendability and maintainability for the community.
Hence, we split the code to define and simulate reaction systems into three Python packages:
symbolite, to create symbolic expressions;
poincaré, to define dynamical systems;
and simbio, to define reaction systems
and interface with systems biology standards such as SBML.

## Symbolite

Symbolite is a lightweight symbolics package to create algebraic mathematical expressions.
They can be inspected and compiled to different backends.
Currently, we have implementations for NumPy (and Numba), SymPy and JAX,
but it is easy to add new backends.

## Poincaré

Poincare is a package to define and simulate dynamical systems.
It provides a `System` class,
where we can define `Constant`s, `Parameter`s, `Variable`s,
and create equations linking a variable's derivative with an expression:

```python
class Decay(System):
    x: Variable = initial(default=1)  # Variable with initial condition
    eq = x.derive() << -x  # equation assigning dx/dt = -x
```

It allows to define higher-order systems
by assigning an initial condition to a `Derivative`:

```python
class Oscillator(System):
    x: Variable = initial(default=1)
    v: Derivative = x.derive(initial=0)
    eq = v.derive() << -x
```

The benefits of using a class to define the system are multiple:

1. the variable name to which a component is assigned can be automatically saved in the component for introspection (i.e., `Oscilator.x.name == "x"`),
2. it provides a namespace such that we can easily define multiple independent models in the same script,
3. it allows IDEs to provide autocomplete and refactoring capabilities (`Oscillator.<TAB>` shows `x`, `v` and `eq`),
4. it allows to create instances which can be composed into a bigger model.

For the latter,
it is important to add the type annotations,
as it can provide a signature autocompletion in IDEs supporting the `dataclass_transform` (PEP 681).

```python
class BigModel(System):
    x: Variable = initial(default=1)
    subsystem = Oscillator(x=x)
    independent = Oscillator(x=1)  # independent variable created inside
```

Using type annotations also allows to statically check for typing errors.
For instance, `Parameter`s can be assigned either a number or a time-dependent expression.
But can also be linked to an outside variable when composing models.
As such, they cannot be used to parametrize the initial conditions of variables,
for which we have to use a `Constant`:

```python
class Model(System):
    k: Constant = assign(default=1, constant=True)
    # two variables sharing initial condition
    x: Variable = initial(default=c)
    y: Variable = initial(default=c)

    p: Parameter = assign(default=1)
    z: Variable = initial(default=p)  # typing error
```

To simulate a system,
we create a `Simulator` instance,
which compiles a given system and interfaces with solvers.
By default, it creates a first-order ordinary differential equation (ODE) system
using `numpy` as a backend.
The Simulator wraps the output in a `pandas.DataFrame`,
which can be easily plotted with the standard `plot` method.

```python
sim = Simulator(Oscillator)
df = sim.solve(save_at=np.linspace(0, 5, 100))

df
```

```python
df.plot()
```

Switching backends to `"numba"` can improve model runtime
on a factor upto x30 or more for big or long running models,
but incurs in a compile time penalty for the first run
which must be taken into account.

## SimBio

For reaction networks,
we are usually interested in first-order differential equations
relating the rate of change of the network's species.

To facilitate defining these models,
SimBio defines `Species`,
which comprises of a `poincare.Variable` and an stoichiometry,
and `Reaction`s,
which transform reactants into products taking into account the stoichiometry.

```python
class Model(Copmartment):
    """2A -> B"""
    A: Species = initial(default=1)
    B: Species = initial(default=0)
    r = Reaction(reactants=[2 * A], product=[B], rate=1)
```

It also includes a `MassAction` variant,
which automatically adds the reactants as part of the rate.
`MassAction(reactants=[2 * A], product=[B], rate=1)`
is equivalent to
`Reaction(reactants=[2 * A], product=[B], rate=1 * A**2)`,
and many predefined commonly used reactions reactions.

SimBio also supports importing from and exporting to SBML,
or directly from BioModels:

```python
from simbio import Simulator
from simbio.io import biomodels, sbml

model = sbml.load("repressilator.sbml")  # from existing SBML file
model = biomodels.load_model("BIOMD12")  # from BioModels
Simulator(model).solve(...)
```

## Other things

units -> Pint
interactive

# Discussion

Modular and extensible set of python libraries
Leverage IDE integration and static typing for model creation

Introduce 3 layers: symbolite, poincare and simbio
easier to understand and develop
usable, extendable, and maintainable by a broader community
protocols
change in the future

# References

::: {#refs}
:::
