---
title: "Poincaré and SimBio: a versatile and extensible Python ecosystem for modeling systems."
bibliography: bibliography.bib
format:
  html:
    number-sections: true
    anchor-sections: true
    css: article.css
  pdf:
    documentclass: scrartcl
    papersize: a4
    geometry:
        - margin=20mm
    pdf-engine: tectonic
    number-sections: true
    colorlinks: true
  docx:
    number-sections: true
---

# Introduction

Chemical Reaction Networks (CRN)
are the foundation of many models used in biological sciences and epidemiology.
They are made up of a set of species and reactions that mediate conversions between them.
There are several ways to simulate these systems:
deterministic Ordinary Differential Equations (ODEs) to model macroscopic behavior,
Stochastic Differential Equations (SDEs) to model microscopic fluctuations,
and jump processes (Gillespie-like simulations) to account for the discreteness of populations.
Instead of writing the equations directly for each of these formulations
which is error-prone and difficult to reuse,
these models can be written in a higher-level description
that can be compiled for these different types of simulations.

Several tools already exist to define and simulate these systems.
In particular,
BioSimulators.org [@shaikhBioSimulatorsCentralRegistry2022],
a registry of simulation tools,
list at least 15 Python softwares.
Some of them are:

1. COPASI [@hoopsCOPASICOmplexPAthway2006],
a stand-alone software
which provides a Graphical User Interface (GUI) to define and simulate models.
2. Tellurium [@choiTelluriumExtensiblePythonbased2018],
which defines itself as a Python-based modeling environment
and uses a C++ library called libRoadRunner [@welshLibRoadRunnerHighPerformance2023] to simulate them.
3. PySB [@lopezProgrammingBiologicalModels2013],
a Python library
that created a DSL using standard Python to define models
which are then compiled to ODE using a Perl library called BioNetGen [@harrisBioNetGenAdvancesRulebased2016].

One limitation of these tools is that they are not extensible from Python,
as they are either built on or use wrapped libraries in other languages.
This means that they allow you to "control" the model definition and simulation in a Python script,
but you cannot use other packages from the vast Python community to change the way the simulation is carried out.
For instance,
to do a Random Parameter Scan in COPASI,
we must choose between one of the predefined distributions,
but cannot use one of the meny distributions from `scipy.stats`.
In a way, we could say that
they make it easier to avoid having to export the simulation results to a CSV file
and then load them into Python for further analysis.

Another weakness is related to the way models are written.
While most tools support standards such as the System Biology Markup Language (SBML) [@huckaSBMLL3V2],
no one is expected to write an SBML file directly.
Tellurium uses a Domain Specific Language (DSL) called Antimony [@smithAntimonyModularModel2009],
which can be translated to SBML.
A DSL allows code to be reused in different programming environments,
but it will not be recognized by Integrated Development Environments (IDEs)
and therefore cannot provide the development experience we have come to expect, such as
syntax highlighting, code completion, refactoring, and static analysis.
This has been recognized by the community,
and an extension for Visual Studio Code has been created [@maTestingDynamicalSystems2021].
However, maintaining it in the future could be burdensome for the smaller systems biology community.
TODO: this is missing for other tools

To address these issues,
we developed poincaré and SimBio,
open-source Python packages for defining and simulating systems.
Poincaré allows to define differential equation systems
and SimBio builds on top of it to define reaction networks.
They are focused on providing an ergonomic experience for end-users
by integrating well with IDEs and static analysis tools
through the use of standard modern Python syntax.
They can be extended from Python
since they are coded in pure Python,
which is beneficial for power users.
For instance, it is easy to reuse integrators defined in other packages,
but it is also possible to change the compilation itself
(the )
Their models can be introspected to create other representations,
such as graphs connecting species and/or reactions,
or tables with parameters or equations.
Finally,
they have a modular architecture with a clear separation of concerns,
making it easier to maintain or to contribute new code,
which is beneficial for developers and maintainers.

# Results

Modular code architecture makes code reusable, extensible, and easier to maintain.
Therefore, we split the code to define and simulate reaction systems into three Python packages:
symbolite, to create symbolic expressions;
poincaré, to define dynamical systems;
and simbio, to define reaction systems and interface with systems biology standards such as SBML.

Symbolite is a lightweight symbolics package to create algebraic mathematical expressions.
They can be inspected and compiled to different backends.
Currently, we have implementations for
NumPy [@harrisArrayProgrammingNumPy2020];
Numba [@lamNumbaLLVMbasedPython2015], a Just-in-Time (JIT) compiler to LLVM;
SymPy [@meurerSymPySymbolicComputing2017], a library for symbolic mathematics;
and JAX [@jax2018github], a library that support automatic differentation
and compilation to GPUs and TPUs;
but it is easy to add new backends.

## Poincaré

```{python}
# | echo: false
from poincare import Derivative, System, Variable, initial


```

:::: {#fig-code layout-nrow=3}

::: {#fig-first-order layout-ncol=3}
```{python}
class Decay(System):
    x: Variable = initial(default=1)
    eq = x.derive() << -x


```

$$
\dot{x} = -x
$$

$$
x(0) = 1
$$

First-order system of an exponential decay.
:::

::: {#fig-second-order layout-ncol=3}
```{python}
class Oscillator(System):
    x: Variable = initial(default=1)
    v: Derivative = x.derive(initial=0)
    eq = v.derive() << -x


```

$$
\ddot{x} = -x
$$

$$
\begin{cases}
    x(0) &= 1 \\
    \dot{x}(0) &= 0
\end{cases}
$$


Second-order system of an harmonic oscillator.
:::

::: {#fig-composition layout-ncol=3}
```{python}
class BigModel(System):
    x: Variable = initial(default=1)
    subsystem = Decay(x=x)
    independent = Decay(x=2)


```

$$
\begin{cases}
    \dot{x} = -x \\
    \dot{y} = -y
\end{cases}
$$

$$
\begin{cases}
    x(0) &= 1 \\
    y(0) &= 2
\end{cases}
$$

First-order system of two exponential decays.
:::

Code and corresponding mathematical expressions for different systems.
::::

Poincare is a package to define and simulate dynamical systems.
It provides a `System` class,
where we can define `Constant`s, `Parameter`s, `Variable`s,
and create equations linking a variable's derivative with an expression (@fig-first-order).
It also allows to define higher-order systems
by assigning an initial condition to a `Derivative` (@fig-second-order).

The benefits of using a class to define the system are multiple:

1. the variable name to which a component is assigned can be automatically saved in the component for introspection (i.e., `Oscilator.x.name == "x"`),
2. it provides a namespace such that we can easily define multiple independent models in the same script,
3. it allows IDEs to provide autocomplete and refactoring capabilities (`Oscillator.<TAB>` shows `x`, `v` and `eq`),
4. it allows to create instances which can be composed into a bigger model (@fig-composition).

For the latter,
it is important to add the type annotations,
as it can provide a signature autocompletion in IDEs supporting the `dataclass_transform` [@debontePEP681Data2021]:

Using type annotations also allows to statically check for typing errors.
For instance, `Parameter`s can be assigned either a number or a time-dependent expression.
But can also be linked to an outside variable when composing models.
As such, they cannot be used to parametrize the initial conditions of variables,
for which we have to use a `Constant`:

```{python}
from poincare import Constant, Parameter, assign

class Model(System):
    c: Constant = assign(default=1, constant=True)
    # two variables sharing initial condition
    x: Variable = initial(default=c)
    y: Variable = initial(default=c)

    p: Parameter = assign(default=1)
    z: Variable = initial(default=p)  # type error
```

To simulate a system,
we create a `Simulator` instance,
which compiles a given system and interfaces with solvers.
By default, it creates a first-order ordinary differential equation (ODE) system
using `numpy` as a backend.
The Simulator wraps the output in a `pandas.DataFrame`,
which can be easily plotted with the standard `plot` method.

```{python}
import numpy as np
from poincare import Simulator

sim = Simulator(Oscillator)
df = sim.solve(save_at=np.linspace(0, 5, 101))

df
```

```{python}
df.plot();
```

Switching backends to `"numba"` can improve model runtime
on a factor upto x30 or more for big or long running models,
but incurs in a compile time penalty for the first run
which must be taken into account.

## SimBio

For reaction networks,
we are usually interested in first-order differential equations
relating the rate of change of the network's species.

To facilitate defining these models,
SimBio defines `Species`,
which comprises of a `poincare.Variable` and an stoichiometry,
and `Reaction`s,
which transform reactants into products taking into account the stoichiometry.

```{python}
from simbio import Compartment, Species, Reaction, initial

class Model(Compartment):
    """2A -> B"""
    A: Species = initial(default=1)
    B: Species = initial(default=0)
    r = Reaction(reactants=[2 * A], products=[B], rate_law=1)
```

It also includes a `MassAction` variant,
which automatically adds the reactants as part of the rate.
`MassAction(reactants=[2 * A], product=[B], rate=1)`
is equivalent to
`Reaction(reactants=[2 * A], product=[B], rate=1 * A**2)`,
and many predefined commonly used reactions reactions.

SimBio also supports importing from and exporting to SBML,
or directly from BioModels:

```python
from simbio import Simulator
from simbio.io import biomodels, sbml

model = sbml.load("repressilator.sbml")  # from existing SBML file
model = biomodels.load_model("BIOMD12")  # from BioModels
Simulator(model).solve(...)
```

## Reproducibility and performance

![Performance of the different softwares to solve a subset of BioModels models. (left) Run time for model BIOMD3 as a function of the number of output points. (right) Run time for different models ordered according to the geometric mean of the run times.](src/performance/figures/performance.png){#fig-runtime}

# Discussion

In this article,
we have described a set of Python packages we developed
that allow to define and simulate dynamical systems and reaction networks.
They are focused on a deep integration with IDEs
such that code analysis tools can flag errors before running the code,
and help with refactoring and code completion.
For this,
we chose to use standard modern Python syntax,
since the integration with IDEs will be maintained by the big players in the huge Python community.

Unlike previous tools,
both model definition and compilation into an ODE function are implemented in Python.
This lowers the barrier to developing different simulation modalities,
such as performance optimizations by leveraging some structure in the model.
However, being in Python does not mean that performance is less than that of C/C++ tools,
as the resulting ODE function can be JITted using Numba.

These packages are designed with a modular architecture that clearly separates different concerns.
This makes them easier to reuse, improve, and extend by the broader Python community.
For example, someone outside the systems biology community could add a stochastic integrator to poincaré,
which could then be used from SimBio.
This architecture also makes them easier to understand,
which reduces the difficulty of contributing fixes or new code,
and ensures their maintenance and continued development into the future.

# References

::: {#refs}
:::
