---
title: "SimBio: a flexible and extensible Python package for systems modelling"
format:
  html:
    number-sections: true
    anchor-sections: true
  pdf:
    documentclass: scrartcl
    papersize: a4
    geometry:
        - margin=20mm
    pdf-engine: tectonic
    number-sections: true
    colorlinks: true
---

# Introduction

Chemical Reaction Networks (CRN)
are the basis of many models used across the biological sciences and epidemiology.
They consist of a set of species and reactions that mediate conversions between them.
Several modalities exist to simulate these systems:
deterministic Ordinary Differential Equations (ODE) which model a macroscopic behavior,
Stochastic Differential Equations (SDE) which model microscopic fluctuations,
and jump processes (Gillespie-like simulations) which take into account the discreteness of the populations.
Hence, it is useful to write these models in a higher level description
which can be reused for these different types of simulations.
equations directly is error-prone and not easily reusable

Several tools already exist to define and simulate these systems.
In particular,
Biosimulators.org,
a registry of simulation tools,
list at least 15 Python softwares
among which are included
COPASI,
Tellurium,
GillesPy2
PySB.
However,
some are only Python wrappers to external (C, C++) libraries.
They allow to "control" the model definition and simulation in a Python script,
but it is not possible to use existing Python packages
to change the way the simulation is carried out.
In other words, they are not extensible from Python.

avoid exporting to csv and loading in Python
large community

To write these models,
there are three main approaches.
Tools such as COPASI provide a Graphical User Interface (GUI),
where the components, relations and their values are defined.
Others use a Domain Specific Language (DSL),
such as Antimony,
which is a less verbose version of the System Biology Markup Language (SBML).
The last approach is to use a programming language such as Python,
which is the approach used by PySB.

Benefits of IDE integration (syntax highlighting, etc)

Here we present SimBio, a Python package to define and simulate reaction networks.
From the end-user point of view,
it is focused on providing an ergonomic experience
by integrating well with IDEs and static analysis tools
through the use of standard modern Python syntax.
From the power-user point of view,
it can be extended from Python,
since its coded in pure Python.
Finally,
from the developer/maintainer point of view,
it has a modular architecture with a clear separation of concerns,
making it easier to maintain or to contribute new code.

the models can be easily introspected,
and simulation extended from Python.
Clean API to create tools (graphs, tables, etc)

# Results

Modular code architecture enhances reusability, extendability and maintainability for the community.
Hence, we split the code to define and simulate reaction systems into three Python packages:
symbolite, to create symbolic expressions;
poincaré, to define dynamical systems;
and simbio, to define reaction systems
and interface with systems biology standards such as SBML.

## Symbolite

Symbolite is a lightweight symbolics package to create algebraic mathematical expressions.
They can be inspected and compiled to different backends.
Currently, we have implementations for NumPy (and Numba), SymPy and JAX,
but it is easy to add new backends.

## Poincaré

Poincare is a package to define and simulate dynamical systems.
It provides a `System` class,
where we can define `Constant`s, `Parameter`s, `Variable`s,
and create equations linking a variable's derivative with an expression:

```python
class Decay(System):
    x: Variable = initial(default=1)  # Variable with initial condition
    eq = x.derive() << -x  # equation assigning dx/dt = -x
```

It allows to define higher-order systems
by assigning an initial condition to a `Derivative`:

```python
class Oscillator(System):
    x: Variable = initial(default=1)
    v: Derivative = x.derive(initial=0)
    eq = v.derive() << -x
```

The benefits of using a class to define the system are multiple:

1. the variable name to which a component is assigned can be automatically saved in the component for introspection (i.e., `Oscilator.x.name == "x"`),
2. it provides a namespace such that we can easily define multiple independent models in the same script,
3. it allows IDEs to provide autocomplete and refactoring capabilities (`Oscillator.<TAB>` shows `x`, `v` and `eq`),
4. it allows to create instances which can be composed into a bigger model.

For the latter,
it is important to add the type annotations,
as it can provide a signature autocompletion in IDEs supporting the `dataclass_transform` (PEP 681).

```python
class BigModel(System):
    x: Variable = initial(default=1)
    subsystem = Oscillator(x=x)
    independent = Oscillator(x=1)  # independent variable created inside
```

Using type annotations also allows to statically check for typing errors.
For instance, `Parameter`s can be assigned either a number or a time-dependent expression.
But can also be linked to an outside variable when composing models.
As such, they cannot be used to parametrize the initial conditions of variables,
for which we have to use a `Constant`:

```python
class Model(System):
    k: Constant = assign(default=1, constant=True)
    # two variables sharing initial condition
    x: Variable = initial(default=c)
    y: Variable = initial(default=c)

    p: Parameter = assign(default=1)
    z: Variable = initial(default=p)  # typing error
```

To simulate a system,
we create a `Simulator` instance,
which compiles a given system and interfaces with solvers.
By default, it creates a first-order ordinary differential equation (ODE) system
using `numpy` as a backend.
The Simulator wraps the output in a `pandas.DataFrame`,
which can be easily plotted with the standard `plot` method.

```python
sim = Simulator(Oscillator)
df = sim.solve(save_at=np.linspace(0, 5, 100))

df
```

```python
df.plot()
```

Switching backends to `"numba"` can improve model runtime
on a factor upto x30 or more for big or long running models,
but incurs in a compile time penalty for the first run
which must be taken into account.

## SimBio

For reaction networks,
we are usually interested in first-order differential equations
relating the rate of change of the network's species.

To facilitate defining these models,
SimBio defines `Species`,
which comprises of a `poincare.Variable` and an stoichiometry,
and `Reaction`s,
which transform reactants into products taking into account the stoichiometry.

```python
class Model(Copmartment):
    """2A -> B"""
    A: Species = initial(default=1)
    B: Species = initial(default=0)
    r = Reaction(reactants=[2 * A], product=[B], rate=1)
```

It also includes a `MassAction` variant,
which automatically adds the reactants as part of the rate.
`MassAction(reactants=[2 * A], product=[B], rate=1)`
is equivalent to
`Reaction(reactants=[2 * A], product=[B], rate=1 * A**2)`,
and many predefined commonly used reactions reactions.

SimBio also supports importing from and exporting to SBML,
or directly from BioModels:

```python
from simbio import Simulator
from simbio.io import biomodels, sbml

model = sbml.load("repressilator.sbml")
model = biomodels.load_model("BIOMD12")  # repressilator model
Simulator(model).solve(...)
```

## Other things

units -> Pint
interactive

# Discussion

Modular and extensible set of python libraries
Leverage IDE integration and static typing for model creation

Introduce 3 layers: symbolite, poincare and simbio
easier to understand and develop
usable, extendable, and maintainable by a broader community
protocols
change in the future
