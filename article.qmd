---
title: "Poincaré and SimBio: a versatile and extensible Python ecosystem for modeling systems."
bibliography: bibliography.bib
format:
  html:
    number-sections: true
    anchor-sections: true
    css: article.css
  pdf:
    documentclass: scrartcl
    papersize: a4
    geometry:
        - margin=20mm
    pdf-engine: tectonic
    number-sections: true
    colorlinks: true
  docx:
    number-sections: true
---

# Introduction

Chemical Reaction Networks (CRN)
are the foundation of many models used in biological sciences and epidemiology.
They are made up of a set of species and reactions that mediate conversions between them.
There are several ways to simulate these systems:
deterministic Ordinary Differential Equations (ODEs) to model macroscopic behavior,
Stochastic Differential Equations (SDEs) to model microscopic fluctuations,
and jump processes (Gillespie-like simulations) to account for the discreteness of populations.
Instead of writing the equations directly for each of these formulations
which is error-prone and difficult to reuse,
these models can be written in a higher-level description
that can be compiled for these different types of simulations.

Several tools already exist to define and simulate these systems.
In particular,
BioSimulators.org [@shaikhBioSimulatorsCentralRegistry2022],
a registry of simulation tools,
list at least 15 Python softwares.
Some of them are:

1. COPASI [@hoopsCOPASICOmplexPAthway2006],
a stand-alone software
which provides a Graphical User Interface (GUI) to define and simulate models.
2. Tellurium [@choiTelluriumExtensiblePythonbased2018],
which defines itself as a Python-based modeling environment
and uses a C++ library called libRoadRunner [@welshLibRoadRunnerHighPerformance2023] to simulate them.
3. PySB [@lopezProgrammingBiologicalModels2013],
a Python library
that created a DSL using standard Python to define models
which are then compiled to ODE using a Perl library called BioNetGen [@harrisBioNetGenAdvancesRulebased2016].

One limitation of these tools is that they are not extensible from Python,
as they are not fully Python packages
but wrap libraries in other languages to do the simulation.
As such, they allow you to "control" the model definition and simulation in a Python script.
But it is not possible to use other packages from the vast Python community to change the way the simulation is carried out.
For instance,
to do a Random Parameter Scan in COPASI,
we must choose between one of 4 predefined distributions,
but cannot use one of the many distributions from `scipy.stats`.
In Tellurium, we cannot choose other Python solvers,
as adding new integrators has to be done in C++.

Another weakness is related to the way models are written.
While most tools support standards such as the System Biology Markup Language (SBML) [@huckaSBMLL3V2],
no one is expected to write an SBML file directly.
Tellurium uses a Domain Specific Language (DSL) called Antimony [@smithAntimonyModularModel2009],
which can be translated to SBML.
A DSL allows code to be reused in different programming environments,
but it will not be recognized by default in Integrated Development Environments (IDEs)
and therefore cannot provide the development experience we have come to expect, such as
syntax highlighting, code completion, refactoring, and static analysis.
This has been recognized by the community,
and an extension for Visual Studio Code has been created [@maTestingDynamicalSystems2021].
However, maintaining it in the future could be burdensome for the smaller systems biology community.
In the case of PySB,
it leveraged the highly dynamic nature of Python to create a DSL within it.
By default, it uses global state to create species and parameters,
without assigning them to Python variables
or adding them explicitly to the model.
But IDEs cannot understand it and, hence, provide help, as this is not the way they expect Python code to be written.

To address these issues,
we developed poincaré and SimBio,
open-source Python packages for defining and simulating systems.
Poincaré allows to define systems of differential equations
and SimBio builds on top of it to define reaction networks.
They are focused on providing an ergonomic experience for end-users
by integrating well with IDEs and static analysis tools
through the use of standard modern Python syntax.
Since they are coded in pure Python,
every part from model definition to simulation can be extended from Python itself.
For example,
easier changes such as reusing integrators defined in other packages,
to more complex ones such as changing the compilation process itself
to leverage some structure in the equations.
Their models can be introspected to create other representations,
such as graphs connecting species and/or reactions,
or tables with parameters or equations.
Finally,
they have a modular architecture with a clear separation of concerns,
making it easier to maintain or to contribute new code,
which is beneficial for developers and maintainers.

# Results

Modular code architecture makes code reusable, extensible, and easier to maintain.
Therefore, we split the code to define and simulate reaction systems into three Python packages:
symbolite, to create symbolic expressions;
poincaré, to define dynamical systems;
and simbio, to define reaction systems and interface with systems biology standards such as SBML.

Symbolite is a lightweight symbolics package to create algebraic mathematical expressions.
They can be inspected and compiled to different backends.
Currently, we have implementations for
NumPy [@harrisArrayProgrammingNumPy2020];
Numba [@lamNumbaLLVMbasedPython2015], a Just-in-Time (JIT) compiler to LLVM;
SymPy [@meurerSymPySymbolicComputing2017], a library for symbolic mathematics;
and JAX [@jax2018github], a library that support automatic differentiation
and compilation to GPUs and TPUs;
and it is easy to add new backends.

## Poincaré

:::: {#fig-poincare layout-nrow=4}

```{python}
from poincare import Derivative, System, Variable, initial


```

::: {#fig-first-order layout-ncol=3}
```{python}
class Decay(System):
    x: Variable = initial(default=1)
    eq = x.derive() << -x


```

$$
\dot{x} = -x
$$

$$
x(0) = 1
$$

First-order system of an exponential decay.
The variable `x` stores the initial condition for $x$,
and the variable `eq` stores the rate equation for $x$.
:::

::: {#fig-second-order layout-ncol=3}
```{python}
class Oscillator(System):
    x: Variable = initial(default=1)
    v: Derivative = x.derive(initial=0)
    eq = v.derive() << -x


```

$$
\ddot{x} = -x
$$

$$
\begin{cases}
    x(0) &= 1 \\
    \dot{x}(0) &= 0
\end{cases}
$$


Second-order system of an harmonic oscillator,
where the variable `v` stores the derivative $\dot{x}$
and the rate equation is specified for the derivative `v`.
:::

::: {#fig-composition layout-ncol=3}
```{python}
class BigModel(System):
    x: Variable = initial(default=1)
    linked = Decay(x=x)
    independent = Decay(x=2)


```

$$
\begin{cases}
    \dot{x} = -x \\
    \dot{y} = -y
\end{cases}
$$

$$
\begin{cases}
    x(0) &= 1 \\
    y(0) &= 2
\end{cases}
$$

First-order system of two exponential decays by composition of the `Decay` system.
The subsystem `linked` has a reference to the outer variable `x`,
while the subsystem `independent` defines a new variable with initial condition §2$,
which on the corresponding mathematical expression was named $y$.
:::

Code and corresponding mathematical expressions for different systems.
::::

Poincare is a package to define and simulate dynamical systems.
It provides a `System` class,
where we can define `Constant`s, `Parameter`s, `Variable`s,
and create equations linking a variable's derivative with an expression (@fig-first-order).
It also allows to define higher-order systems
by assigning an initial condition to a `Derivative` (@fig-second-order).

The benefits of using a class to define the system are multiple:

1. the variable name to which a component is assigned can be automatically saved in the component for introspection (i.e., `Oscilator.x.name == "x"`),
2. it provides a namespace such that we can easily define multiple independent models in the same script,
3. it allows IDEs to provide autocomplete and refactoring capabilities (`Oscillator.<TAB>` shows `x`, `v` and `eq`),
4. it allows to create instances which can be composed into a bigger model (@fig-composition).

For the latter,
it is important to add the type annotations,
as it can provide a signature autocompletion in IDEs supporting the `dataclass_transform` [@debontePEP681Data2021]:

Using type annotations also allows to statically check for typing errors.
For instance, `Parameter`s can be assigned either a number or a time-dependent expression.
But can also be linked to an outside variable when composing models.
As such, they cannot be used to parametrize the initial conditions of variables,
for which we have to use a `Constant` (@fig-constant).

::: {#fig-constant layout-nrow=2}
```{python}
# | echo: false
from poincare import Constant, Parameter, assign


```

```{python}
class Model(System):
    c: Constant = assign(default=1, constant=True)
    x: Variable = initial(default=c)
    y: Variable = initial(default=c)


```

```{python}
class BadModel(System):
    p: Parameter = assign(default=1)
    z: Variable = initial(default=p)  # type error


```

Constant and Parameter allow to connect initial conditions and equations, respectively.
Using Parameters as initial conditions raises an error,
and can be flagged by static type checkers.
:::

To simulate a system,
we create a `Simulator` instance (@fig-sim),
which compiles a given system and interfaces with solvers.
By default, it creates a first-order ordinary differential equation (ODE) system
using `numpy` as a backend.
The Simulator wraps the output in a `pandas.DataFrame`,
which can be easily plotted with the standard `plot` method.

::: {#fig-sim layout=[[1],[1,1]]}
```{python}
import numpy as np
from poincare import Simulator

sim = Simulator(Oscillator)
df = sim.solve(save_at=np.linspace(0, 5, 101))
```

```{python}
df.head()
```

```{python}
df.plot(figsize=(4, 2))
```

Simulation of the `Oscillator` system from @fig-second-order.
The output is a `pandas.DataFrame` with a column for each variable
and the time as index.
It is inspected and plotted with the `pandas` methods.
:::

Switching backends to `"numba"` can improve model runtime
on a factor up to x30 or more for big or long running models,
but incurs in a compile time penalty for the first run
which must be taken into account.

## SimBio

:::: {#fig-simbio layout-nrow=3}

```{python}
from simbio import Compartment, MassAction, Species, Reaction, initial


```

::: {layout-ncol=2}
```{python}
class Model(Compartment):
    """2A -> B"""

    A: Species = initial(default=1)
    B: Species = initial(default=0)
    r = Reaction(
        reactants=[2 * A],
        products=[B],
        rate_law=1,
    )


```

$$
\begin{align}
&\begin{cases}
    \frac{dA}{dt} = -2 \\
    \frac{dB}{dt} = +1
\end{cases}
\\\\
&\begin{cases}
    A(0) &= 1 \\
    B(0) &= 0
\end{cases}
\end{align}
$$
:::

::: {layout-ncol=2}
```{python}
class Model(Compartment):
    """2A -> B"""

    A: Species = initial(default=1)
    B: Species = initial(default=0)
    r = MassAction(
        reactants=[2 * A],
        products=[B],
        rate=1,
    )


```

$$
\begin{align}
&\begin{cases}
    \frac{dA}{dt} = -2 A^2 \\
    \frac{dB}{dt} = +1 A^2
\end{cases}
\\\\
&\begin{cases}
    A(0) &= 1 \\
    B(0) &= 0
\end{cases}
\end{align}
$$
:::

A reaction system for species $A$ and $B$ with initial conditions $1$ and $0$, respectively.
A single reaction transforming $2A$ into $B$ is saved in variable `r`.
The rate $1$ is specified directly for `Reaction`,
and is proportional to the reactants for `MassAction`.
::::

For reaction networks,
we are interested in first-order differential equations
relating the rate of change of the species.
To facilitate defining these models,
SimBio defines `Species`,
which comprises of a `poincare.Variable` and an stoichiometry,
and `Reaction`,
which transform reactants into products taking into account the stoichiometry (@fig-simbio).
It also includes `MassAction`, a `Reaction` subclass,
which automatically adds the reactants as part of the rate law (@fig-simbio).
Several commonly used reactions are predefined as `MassAction` subclasses.
Additionally, SimBio supports importing from and exporting to SBML,
or directly from BioModels (@fig-simbio-io).

::: {#fig-simbio-io layout-ncol=1}
```{python}
from simbio.io import biomodels, sbml

model = sbml.load("repressilator.sbml")  # from existing SBML file
model = biomodels.load_model("BIOMD12")  # from BioModels
```

Creation of a model from a local SBML file or one uploaded to BioModels.
:::

## Reproducibility and performance

![Performance of the different softwares to solve a subset of BioModels models. (left) Run time for model BIOMD3 as a function of the number of output points. (right) Run time for different models ordered according to the geometric mean of the run times, using 300 output points.](src/performance/figures/performance.png){#fig-runtime}

To test the reproducibility of results of SimBio,
we considered the first 100 curated models from BioModels.
As SimBio does not yet support the full SBML standard,
for instance, events,
we simulated only 60 of those.
Using the results from COPASI as ground truth,
SimBio reproduces the results within the solver tolerances.

To test the performance,
we simulated them with COPASI, Tellurium/RoadRunner and simbio.
For simbio, we considered both the NumPy and numba backends.
For COPASI and simbio, we used the LSODA solver,
while using the similar CVODE solver for tellurium.
In all cases, we used relative and absolute tolerances of  $10^-6$.
We measured separately three stages of the simulation:
the loading, first/cold run and subsequent/warm runs of each model.

For COPASI and Tellurium/RoadRunner,
we noted that its runtime depended on the number of evaluation points,
something that does not seem to happen with SimBio (@fig-runtime, left).
While SimBio's NumPy backend is slower than both COPASI and RoadRunner,
we obtained an order of magnitude speed-up using the numba backend putting it on par with them.
A user might have to consider the trade-off between compilation and run times,
as the compilation of the right-hand-side (RHS) code might take longer than the runtime itself,
and not be worth it for running the model only once.
Another speed-up in the runtime can be had
by switching the LSODA `scipy` solver for a more efficient `numbalsoda` implementation,
which avoids the Python interpreter between each of the integration steps.
This last combination beats all other methods,
which is also true for the other models we tested (@fig-runtime, right).


# Discussion

In this article,
we have described a set of Python packages we developed
that allow to define and simulate dynamical systems and reaction networks.
They are focused on a deep integration with IDEs
such that code analysis tools can flag errors before running the code,
and help with refactoring and code completion.
For this,
we chose to use standard modern Python syntax,
since the integration with IDEs will be maintained by the big players in the huge Python community.

Unlike previous tools,
both model definition and compilation into an ODE function are implemented in Python.
This lowers the barrier to developing different simulation modalities,
such as performance optimizations by leveraging some structure in the model.
However, being in Python does not mean that performance is less than that of C/C++ tools,
as the resulting ODE function can be JITted using Numba.

These packages are designed with a modular architecture that clearly separates different concerns.
This makes them easier to reuse, improve, and extend by the broader Python community.
For example, someone outside the systems biology community could add a stochastic integrator to poincaré,
which could then be used from SimBio.
This architecture also makes them easier to understand,
which reduces the difficulty of contributing fixes or new code,
and ensures their maintenance and continued development into the future.

# References

::: {#refs}
:::
